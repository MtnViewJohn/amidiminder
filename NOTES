NOTES


# TODO

## state and profiles

[x] command line change to commands
    [x] modes
    [x] minder command
    [x] check command
    [x] print help on no args at all
    [x] help subcommand
    [x] add ExistingPathValidator() to rules file arguments
    [x] version flag? (set_version_flag())
    [x] load rules only after command is switched


[] file locations in code somewhere
    [x] built from optional environment variables
    [x] need to decide how much checking to do
    [x] need to exit when files aren't good
    [x] file reading & file writing utilities
    [x] check file actions
        [x] read from supplied path
    [x] read state (profile & observed) on state on start
    [x] don't crash on empty statefiles... just be happy
    [x] write observed on changes
    [] handle "-" to mean stdin/stdout
    [] safe file write code (write to .save, rename)

[] reorg
    [x] rename command to daemon
    [x] move main and control commands out of MidiMinder class
    [x] refactor MidiMinder
    [x] rename configRules in MM profileRules
    [x] make the files be observed.rules and profile.rules
        [x] socket should be control.socket
    [x] move Files::initialize* into IPC code
    [] change commtest command on the wire from "ahoy" to "commtest"
        [] find suitable haiku for the commtest command

[] command line and deamon communication
    [x] commtest command
    [x] use poll or epoll with seq & the socket
    [x] reset command
    [x] load command
    [] save command
    [] command logging should be done by each command handler

[] new observed connection/disconnection logic
    [x] reset on start
    [] correctly adjusting observed rules if needed
    [] improve messages to the log on adding / removing observed rules
    [] checking for rule consistency
    [] expected disconnect optimization
    [x] remove Reason enum

[] Primary port logic - and general refactor
    [] ? on reset just scan activeConnections
    [x] on addPort, figure out if port is primary
    [x] print something for primary ports
    [x] is it reasonable to assume we'll see PORT_START events
        before any PORT_SUBSCRIBE or PORT_UNSUBSCRIBE events
        that reference those ports? yes, I think so
    [x] when scanning ports, do they come out in order
        - yes, yes they do - the kernel does this explicitly

[] man pages
    [] amidiminder(1)
    [] amidiminder-profile(5)
        [] needs more examples at the end
    [] amidiminder-daemon(8)
    [] ? symlink all the user commands, like:
            amidiminder-load(1) -> amidiminder(1)


## aconnect functionality

[] connect & disconnect
[] list

## other

[] improve output of check command
[] switch to throwing errors on fatal system (and Seq) errors
[] review all error messages
    [] leading case
    [] wording
[] handle socket errors in the IPC code intellegently
    [] client wants to report and exit
    [] server wants to report and discard (aborting the command in progress)
    [x] calls to write in ipc.cpp should have the return value checked
[] move verbose port details option to the list command
[x] harmonize CPP_FLAGS with what happens when built for deb
    [] fix CPP_FLAGS for debugging to -Og
[] group subcommands in Args to make help more clear
[] print rules when loading profile?
[] optimize saving observedRules
[] don't rebuild ports on reset - should be no need
[] ? case insensitive client and port name matches

## future

[] periodically check clients and ports for name and capability changes
    (since, due to kernel bugs, the change events are never sent), and if there
    are changes, remove and re-add the relevant ports
    N.B.: Not clear this is really needed, since we don't see any applications
    that really change port names or capabilities after being created. See the
    code in MidiMinder::handleSeqEvent for details about client name changes.

# MAJOR THEMES

## aconnect functionality
    - using the better syntax and naming for making, listing
    - and breaking connections
    - clear all connections

## connection state
    - keep what is intended even across reboot
    - create provisional rules when connections are made
    - (and delete them when broken)
    - save those in a live file (in /etc?)
    - on load use the user written set & the saved set

## connection setups
    - named setups - one is active
    - merge setups?
    - save current state as a setup
    - files in standard places

## maturty
    - man page
    - bash completion
    - SIGHUP for reload
    - handle daemon running or not


# DESIGN

Two rules files:
    Profile
        come from user
        symlink from /etc/amidiminder.rules to ???
        how to recognize chances in rules?
            - observe file change?
            - command to switch the symlink?
            - signal to reload?
    Observed
        from observations of connects and disconnects
        relative to the Profile rules
            a connect that the Profile rules would make won't be recorded
            has to be able to record overrides of the Profile rules

    Static & Dynamic?

Modes:
    daemon          - like the current operation
    connect         - make a connection, the minder will see it
    disconnect      - break a connection, the minder will see it
    reset           - clear the live rules, reset to only connections from Profile
    load            - set new Profile rules & reset
    save            - save the current Profile & Observed rules as new single rules file
    check           - check rule set file
    list            - show devices, ports, and connections


# DAW NOTES

PureData
    - When changing number of MIDI ports, deletes them all
      then re-adds them. This works for us.
    - OMG - it sets the name of the client AFTER it creates the ports

Renoise
    - Has separate clients for In and Out!
    - Has non-exported ports first, so user ports don't start from zero
    - Adds and removes ports, at times willy-nilly. If you connect a port
      to a device in the app, it deletes its port, recreates it named with
      the name of the other port, and then connects them.  This seems okay
      with midiminder
    - ? Perhaps we want a "ignore client" list - since Renoise does a fine
      job of managing MIDI ports on it's own.
    - Interestingly: no output ports other than sync!!

Reaper
    - Normally talks to raw MIDI devices
    - Has one "virtual" in and one "virtual" out port, each uses its own
      ALSA client (!), and the clients are named "Client-128" and "Client-129",
      the ports are named "Virtual RawMIDI" no matter what they are renamed in
      the UI.

LMMS
    - Lets users pick other ALSA ports as MIDI in/out for specific tracks
    - Will create a port and connect it for each such assignment
    - Doesn't seem to notice when connections are changed outside of it
    -

Ardour
    - Creates a ton of clients: A pair for each other ALSA port, each client
      has one port in or out. These are connected to each of the other
      ports. BUT, none of the Ardour ports are marked subs - so no idea how
      these connections are made.
    [] caused amidiminder to generate ALSA Seq error -2 in get client info
    [] need to make sure these ports are completely and correctly ignored

bitwig - only x86-64 available
